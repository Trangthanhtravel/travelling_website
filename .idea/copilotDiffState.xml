<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/controllers/serviceController.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/controllers/serviceController.js" />
              <option name="originalContent" value="const { getDB, generateId, generateBookingNumber } = require('../config/database');&#10;const Service = require('../models/Service');&#10;const Category = require('../models/Category');&#10;const { r2Helpers } = require('../config/storage');&#10;const multer = require('multer');&#10;&#10;// Configure multer for memory storage (files will be uploaded to R2)&#10;const storage = multer.memoryStorage();&#10;const upload = multer({&#10;  storage: storage,&#10;  limits: {&#10;    fileSize: 5 * 1024 * 1024, // 5MB limit&#10;  },&#10;  fileFilter: (req, file, cb) =&gt; {&#10;    // Accept only image files&#10;    if (file.mimetype.startsWith('image/')) {&#10;      cb(null, true);&#10;    } else {&#10;      cb(new Error('Only image files are allowed'), false);&#10;    }&#10;  }&#10;});&#10;&#10;// Get all services with filtering&#10;const getServices = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const {&#10;      category,&#10;      serviceType,&#10;      status = 'active',&#10;      featured,&#10;      search,&#10;      page = 1,&#10;      limit = 12,&#10;      sortBy = 'created_at',&#10;      sortOrder = 'desc'&#10;    } = req.query;&#10;&#10;    // Updated query to join with categories table&#10;    let query = `&#10;      SELECT s.*, c.name as category_name, c.slug as category_slug, c.icon as category_icon, c.color as category_color&#10;      FROM services s&#10;      LEFT JOIN categories c ON s.category_id = c.id&#10;    `;&#10;    const conditions = [];&#10;    const params = [];&#10;&#10;    // Only show active services for non-admin users&#10;    if (req.user?.role !== 'admin') {&#10;      conditions.push('s.status = ?');&#10;      params.push('active');&#10;    } else if (status) {&#10;      conditions.push('s.status = ?');&#10;      params.push(status);&#10;    }&#10;&#10;    // Filter by category slug or ID&#10;    if (category) {&#10;      conditions.push('(c.slug = ? OR s.category_id = ?)');&#10;      params.push(category, category);&#10;    }&#10;&#10;    if (serviceType) {&#10;      conditions.push('s.service_type = ?');&#10;      params.push(serviceType);&#10;    }&#10;&#10;    if (featured !== undefined) {&#10;      conditions.push('s.featured = ?');&#10;      params.push(featured === 'true' ? 1 : 0);&#10;    }&#10;&#10;    if (search) {&#10;      conditions.push('(s.title LIKE ? OR s.subtitle LIKE ? OR s.description LIKE ?)');&#10;      const searchTerm = `%${search}%`;&#10;      params.push(searchTerm, searchTerm, searchTerm);&#10;    }&#10;&#10;    if (conditions.length &gt; 0) {&#10;      query += ' WHERE ' + conditions.join(' AND ');&#10;    }&#10;&#10;    // Add sorting&#10;    const validSortColumns = ['created_at', 'title', 'price', 'updated_at'];&#10;    const validSortOrders = ['asc', 'desc'];&#10;&#10;    if (validSortColumns.includes(sortBy) &amp;&amp; validSortOrders.includes(sortOrder)) {&#10;      query += ` ORDER BY s.${sortBy} ${sortOrder.toUpperCase()}`;&#10;    }&#10;&#10;    // Add pagination&#10;    const offset = (parseInt(page) - 1) * parseInt(limit);&#10;    query += ` LIMIT ? OFFSET ?`;&#10;    params.push(parseInt(limit), offset);&#10;&#10;    const result = await db.prepare(query).bind(...params).all();&#10;&#10;    // Get total count for pagination&#10;    let countQuery = `&#10;      SELECT COUNT(*) as total &#10;      FROM services s&#10;      LEFT JOIN categories c ON s.category_id = c.id&#10;    `;&#10;    if (conditions.length &gt; 0) {&#10;      countQuery += ' WHERE ' + conditions.join(' AND ');&#10;    }&#10;&#10;    const countResult = await db.prepare(countQuery).bind(...params.slice(0, -2)).first();&#10;    const total = countResult?.total || 0;&#10;&#10;    // Process results and include category information&#10;    const services = result.results?.map(service =&gt; ({&#10;      ...service,&#10;      images: service.images ? JSON.parse(service.images) : [],&#10;      videos: service.videos ? JSON.parse(service.videos) : [],&#10;      included: service.included ? JSON.parse(service.included) : [],&#10;      excluded: service.excluded ? JSON.parse(service.excluded) : [],&#10;      itinerary: service.itinerary ? JSON.parse(service.itinerary) : [],&#10;      location: service.location ? JSON.parse(service.location) : null,&#10;      featured: Boolean(service.featured),&#10;      category: service.category_id ? {&#10;        id: service.category_id,&#10;        name: service.category_name,&#10;        slug: service.category_slug,&#10;        icon: service.category_icon,&#10;        color: service.category_color&#10;      } : null&#10;    })) || [];&#10;&#10;    res.json({&#10;      success: true,&#10;      data: services,&#10;      pagination: {&#10;        currentPage: parseInt(page),&#10;        totalPages: Math.ceil(total / parseInt(limit)),&#10;        totalItems: total,&#10;        hasNext: parseInt(page) &lt; Math.ceil(total / parseInt(limit)),&#10;        hasPrev: parseInt(page) &gt; 1&#10;      }&#10;    });&#10;  } catch (error) {&#10;    console.error('Error fetching services:', error);&#10;    res.status(500).json({ success: false, message: 'Internal server error' });&#10;  }&#10;};&#10;&#10;// Get single service by ID&#10;const getServiceById = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const { id } = req.params;&#10;&#10;    // Updated query to include category information&#10;    const query = `&#10;      SELECT s.*, c.name as category_name, c.slug as category_slug, c.icon as category_icon, c.color as category_color&#10;      FROM services s&#10;      LEFT JOIN categories c ON s.category_id = c.id&#10;      WHERE s.id = ? AND (s.status = &quot;active&quot; OR ? = &quot;admin&quot;)&#10;    `;&#10;&#10;    const result = await db.prepare(query).bind(id, req.user?.role || '').first();&#10;&#10;    if (!result) {&#10;      return res.status(404).json({ success: false, message: 'Service not found' });&#10;    }&#10;&#10;    const service = {&#10;      ...result,&#10;      images: result.images ? JSON.parse(result.images) : [],&#10;      videos: result.videos ? JSON.parse(result.videos) : [],&#10;      included: result.included ? JSON.parse(result.included) : [],&#10;      excluded: result.excluded ? JSON.parse(result.excluded) : [],&#10;      itinerary: result.itinerary ? JSON.parse(result.itinerary) : [],&#10;      location: result.location ? JSON.parse(result.location) : null,&#10;      featured: Boolean(result.featured),&#10;      category: result.category_id ? {&#10;        id: result.category_id,&#10;        name: result.category_name,&#10;        slug: result.category_slug,&#10;        icon: result.category_icon,&#10;        color: result.category_color&#10;      } : null&#10;    };&#10;&#10;    res.json({ success: true, data: service });&#10;  } catch (error) {&#10;    console.error('Error fetching service:', error);&#10;    res.status(500).json({ success: false, message: 'Internal server error' });&#10;  }&#10;};&#10;&#10;// Create service booking&#10;const createServiceBooking = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const {&#10;      serviceId,&#10;      serviceType,&#10;      name,&#10;      email,&#10;      gender,&#10;      dateOfBirth,&#10;      phone,&#10;      address,&#10;      passengers,&#10;      departureDate,&#10;      from,&#10;      to,&#10;      returnTrip,&#10;      returnDate,&#10;      tripDetails,&#10;      requestDetails&#10;    } = req.body;&#10;&#10;    // Validate required fields&#10;    if (!serviceId || !name || !email || !phone || !passengers) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'Missing required fields'&#10;      });&#10;    }&#10;&#10;    // Check if service exists&#10;    const service = await db.prepare('SELECT * FROM services WHERE id = ? AND status = &quot;active&quot;')&#10;      .bind(serviceId).first();&#10;&#10;    if (!service) {&#10;      return res.status(404).json({ success: false, message: 'Service not found' });&#10;    }&#10;&#10;    // Validate service type specific fields&#10;    if (serviceType === 'tours' &amp;&amp; !departureDate) {&#10;      return res.status(400).json({ success: false, message: 'Departure date is required for tours' });&#10;    }&#10;&#10;    if (serviceType === 'car-rental' &amp;&amp; (!departureDate || !from || !to || !tripDetails)) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'Departure date, from, to, and trip details are required for car rental'&#10;      });&#10;    }&#10;&#10;    if (serviceType === 'other-services' &amp;&amp; !requestDetails) {&#10;      return res.status(400).json({ success: false, message: 'Request details are required for other services' });&#10;    }&#10;&#10;    const bookingId = generateId();&#10;    const bookingNumber = generateBookingNumber();&#10;&#10;    // Prepare booking form data&#10;    const bookingForm = {&#10;      serviceId,&#10;      serviceType,&#10;      name,&#10;      email,&#10;      gender,&#10;      dateOfBirth,&#10;      phone,&#10;      address,&#10;      passengers,&#10;      ...(departureDate &amp;&amp; { departureDate }),&#10;      ...(from &amp;&amp; { from }),&#10;      ...(to &amp;&amp; { to }),&#10;      ...(returnTrip !== undefined &amp;&amp; { returnTrip }),&#10;      ...(returnDate &amp;&amp; { returnDate }),&#10;      ...(tripDetails &amp;&amp; { tripDetails }),&#10;      ...(requestDetails &amp;&amp; { requestDetails })&#10;    };&#10;&#10;    const query = `&#10;      INSERT INTO service_bookings (&#10;        id, booking_number, service_id, customer_id, booking_form, status&#10;      ) VALUES (?, ?, ?, ?, ?, 'pending')&#10;    `;&#10;&#10;    await db.prepare(query).bind(&#10;      bookingId,&#10;      bookingNumber,&#10;      serviceId,&#10;      req.user.id,&#10;      JSON.stringify(bookingForm)&#10;    ).run();&#10;&#10;    res.status(201).json({&#10;      success: true,&#10;      message: 'Service booking created successfully',&#10;      data: { bookingNumber }&#10;    });&#10;  } catch (error) {&#10;    console.error('Error creating service booking:', error);&#10;    res.status(500).json({ success: false, message: 'Internal server error' });&#10;  }&#10;};&#10;&#10;// Get user's service bookings&#10;const getUserServiceBookings = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const query = `&#10;      SELECT sb.*, s.title as service_title, s.subtitle as service_subtitle, s.images as service_images&#10;      FROM service_bookings sb&#10;      JOIN services s ON sb.service_id = s.id&#10;      WHERE sb.customer_id = ?&#10;      ORDER BY sb.created_at DESC&#10;    `;&#10;&#10;    const result = await db.prepare(query).bind(req.user.id).all();&#10;&#10;    const bookings = result.results?.map(booking =&gt; ({&#10;      ...booking,&#10;      booking_form: booking.booking_form ? JSON.parse(booking.booking_form) : {},&#10;      notes: booking.notes ? JSON.parse(booking.notes) : [],&#10;      service: {&#10;        title: booking.service_title,&#10;        subtitle: booking.service_subtitle,&#10;        images: booking.service_images ? JSON.parse(booking.service_images) : []&#10;      }&#10;    })) || [];&#10;&#10;    res.json({ success: true, data: bookings });&#10;  } catch (error) {&#10;    console.error('Error fetching user service bookings:', error);&#10;    res.status(500).json({ success: false, message: 'Internal server error' });&#10;  }&#10;};&#10;&#10;// Admin: Get all service bookings&#10;const getAllServiceBookings = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const {&#10;      status,&#10;      serviceType,&#10;      page = 1,&#10;      limit = 20,&#10;      sortBy = 'created_at',&#10;      sortOrder = 'desc'&#10;    } = req.query;&#10;&#10;    let query = `&#10;      SELECT sb.*, s.title as service_title, s.service_type, u.name as customer_name, u.email as customer_email&#10;      FROM service_bookings sb&#10;      JOIN services s ON sb.service_id = s.id&#10;      JOIN users u ON sb.customer_id = u.id&#10;    `;&#10;&#10;    const conditions = [];&#10;    const params = [];&#10;&#10;    if (status) {&#10;      conditions.push('sb.status = ?');&#10;      params.push(status);&#10;    }&#10;&#10;    if (serviceType) {&#10;      conditions.push('s.service_type = ?');&#10;      params.push(serviceType);&#10;    }&#10;&#10;    if (conditions.length &gt; 0) {&#10;      query += ' WHERE ' + conditions.join(' AND ');&#10;    }&#10;&#10;    // Add sorting&#10;    const validSortColumns = ['created_at', 'updated_at', 'booking_number'];&#10;    const validSortOrders = ['asc', 'desc'];&#10;&#10;    if (validSortColumns.includes(sortBy) &amp;&amp; validSortOrders.includes(sortOrder)) {&#10;      query += ` ORDER BY sb.${sortBy} ${sortOrder.toUpperCase()}`;&#10;    }&#10;&#10;    // Add pagination&#10;    const offset = (parseInt(page) - 1) * parseInt(limit);&#10;    query += ` LIMIT ? OFFSET ?`;&#10;    params.push(parseInt(limit), offset);&#10;&#10;    const result = await db.prepare(query).bind(...params).all();&#10;&#10;    const bookings = result.results?.map(booking =&gt; ({&#10;      ...booking,&#10;      booking_form: booking.booking_form ? JSON.parse(booking.booking_form) : {},&#10;      notes: booking.notes ? JSON.parse(booking.notes) : []&#10;    })) || [];&#10;&#10;    res.json({ success: true, data: bookings });&#10;  } catch (error) {&#10;    console.error('Error fetching service bookings:', error);&#10;    res.status(500).json({ success: false, message: 'Internal server error' });&#10;  }&#10;};&#10;&#10;// Admin: Update service booking status&#10;const updateServiceBookingStatus = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const { id } = req.params;&#10;    const { status, note } = req.body;&#10;&#10;    if (!['pending', 'contacted', 'confirmed', 'completed', 'cancelled'].includes(status)) {&#10;      return res.status(400).json({ success: false, message: 'Invalid status' });&#10;    }&#10;&#10;    // Check if booking exists&#10;    const booking = await db.prepare('SELECT * FROM service_bookings WHERE id = ?').bind(id).first();&#10;    if (!booking) {&#10;      return res.status(404).json({ success: false, message: 'Booking not found' });&#10;    }&#10;&#10;    // Update status and timestamps&#10;    let updateFields = ['status = ?', 'updated_at = CURRENT_TIMESTAMP'];&#10;    let params = [status];&#10;&#10;    if (status === 'contacted') {&#10;      updateFields.push('contacted_at = CURRENT_TIMESTAMP');&#10;    } else if (status === 'confirmed') {&#10;      updateFields.push('confirmed_at = CURRENT_TIMESTAMP');&#10;    }&#10;&#10;    // Add note if provided&#10;    if (note) {&#10;      const existingNotes = booking.notes ? JSON.parse(booking.notes) : [];&#10;      const newNote = {&#10;        content: note,&#10;        author: req.user.name,&#10;        createdAt: new Date().toISOString()&#10;      };&#10;      updateFields.push('notes = ?');&#10;      params.push(JSON.stringify([...existingNotes, newNote]));&#10;    }&#10;&#10;    const query = `UPDATE service_bookings SET ${updateFields.join(', ')} WHERE id = ?`;&#10;    params.push(id);&#10;&#10;    await db.prepare(query).bind(...params).run();&#10;&#10;    res.json({ success: true, message: 'Booking status updated successfully' });&#10;  } catch (error) {&#10;    console.error('Error updating service booking status:', error);&#10;    res.status(500).json({ success: false, message: 'Internal server error' });&#10;  }&#10;};&#10;&#10;// Admin: Create new service&#10;const createService = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const serviceData = req.body;&#10;    &#10;    // Parse JSON fields from FormData if they're strings&#10;    if (serviceData.included &amp;&amp; typeof serviceData.included === 'string') {&#10;      serviceData.included = JSON.parse(serviceData.included);&#10;    }&#10;    if (serviceData.excluded &amp;&amp; typeof serviceData.excluded === 'string') {&#10;      serviceData.excluded = JSON.parse(serviceData.excluded);&#10;    }&#10;    if (serviceData.features &amp;&amp; typeof serviceData.features === 'string') {&#10;      serviceData.features = JSON.parse(serviceData.features);&#10;    }&#10;&#10;    // Create new service instance&#10;    const service = new Service({&#10;      title: serviceData.name,&#10;      subtitle: serviceData.subtitle || '',&#10;      description: serviceData.description,&#10;      price: parseFloat(serviceData.price),&#10;      duration: serviceData.duration,&#10;      category: serviceData.category,&#10;      service_type: serviceData.category, // Map category to service_type&#10;      included: serviceData.features || [],&#10;      excluded: serviceData.excluded || [],&#10;      status: serviceData.status || 'active',&#10;      featured: serviceData.featured || false&#10;    });&#10;&#10;    // Handle image uploads if files are provided&#10;    if (req.files &amp;&amp; req.files.length &gt; 0) {&#10;      try {&#10;        const uploadedImages = await service.updateImages(&#10;          process.env.R2_BUCKET_NAME,&#10;          req.files,&#10;          []&#10;        );&#10;        console.log(`Uploaded ${uploadedImages.length} images for service`);&#10;      } catch (imageError) {&#10;        console.error('Image upload error:', imageError);&#10;        return res.status(400).json({&#10;          success: false,&#10;          message: 'Error uploading images: ' + imageError.message&#10;        });&#10;      }&#10;    }&#10;&#10;    // Save service to database&#10;    const result = await service.save(db);&#10;    &#10;    res.status(201).json({&#10;      success: true,&#10;      message: 'Service created successfully',&#10;      data: service.toJSON ? service.toJSON() : service&#10;    });&#10;  } catch (error) {&#10;    console.error('Create service error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error creating service: ' + error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Admin: Update existing service&#10;const updateService = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const { id } = req.params;&#10;    const updateData = req.body;&#10;&#10;    // Check if service exists&#10;    const existingService = await Service.findById(db, id);&#10;    if (!existingService) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Service not found'&#10;      });&#10;    }&#10;&#10;    // Parse JSON fields if they're strings&#10;    if (updateData.included &amp;&amp; typeof updateData.included === 'string') {&#10;      updateData.included = JSON.parse(updateData.included);&#10;    }&#10;    if (updateData.excluded &amp;&amp; typeof updateData.excluded === 'string') {&#10;      updateData.excluded = JSON.parse(updateData.excluded);&#10;    }&#10;    if (updateData.features &amp;&amp; typeof updateData.features === 'string') {&#10;      updateData.features = JSON.parse(updateData.features);&#10;    }&#10;&#10;    // Prepare update data&#10;    const serviceUpdateData = {&#10;      title: updateData.name || existingService.title,&#10;      subtitle: updateData.subtitle || existingService.subtitle,&#10;      description: updateData.description || existingService.description,&#10;      price: updateData.price ? parseFloat(updateData.price) : existingService.price,&#10;      duration: updateData.duration || existingService.duration,&#10;      category: updateData.category || existingService.category,&#10;      service_type: updateData.category || existingService.service_type,&#10;      included: updateData.features || existingService.included,&#10;      excluded: updateData.excluded || existingService.excluded,&#10;      status: updateData.status || existingService.status,&#10;      featured: updateData.featured !== undefined ? updateData.featured : existingService.featured,&#10;      updated_at: new Date().toISOString()&#10;    };&#10;&#10;    // Handle image uploads if new files are provided&#10;    if (req.files &amp;&amp; req.files.length &gt; 0) {&#10;      try {&#10;        const uploadedImages = await existingService.updateImages(&#10;          process.env.R2_BUCKET_NAME,&#10;          req.files,&#10;          existingService.images || []&#10;        );&#10;        serviceUpdateData.images = JSON.stringify(uploadedImages);&#10;        console.log(`Updated ${uploadedImages.length} images for service`);&#10;      } catch (imageError) {&#10;        console.error('Image update error:', imageError);&#10;        return res.status(400).json({&#10;          success: false,&#10;          message: 'Error updating images: ' + imageError.message&#10;        });&#10;      }&#10;    }&#10;&#10;    // Update service in database&#10;    await existingService.update(db, serviceUpdateData);&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Service updated successfully',&#10;      data: { ...existingService, ...serviceUpdateData }&#10;    });&#10;  } catch (error) {&#10;    console.error('Update service error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error updating service: ' + error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Admin: Delete service&#10;const deleteService = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const { id } = req.params;&#10;&#10;    // Check if service exists&#10;    const service = await Service.findById(db, id);&#10;    if (!service) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Service not found'&#10;      });&#10;    }&#10;&#10;    // Delete service (this will also handle image cleanup)&#10;    await service.delete(db, process.env.R2_BUCKET_NAME);&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Service deleted successfully'&#10;    });&#10;  } catch (error) {&#10;    console.error('Delete service error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error deleting service: ' + error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Admin: Update service status&#10;const updateServiceStatus = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const { id } = req.params;&#10;    const { status } = req.body;&#10;&#10;    if (!['active', 'inactive'].includes(status)) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'Invalid status. Must be &quot;active&quot; or &quot;inactive&quot;'&#10;      });&#10;    }&#10;&#10;    // Check if service exists&#10;    const service = await Service.findById(db, id);&#10;    if (!service) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Service not found'&#10;      });&#10;    }&#10;&#10;    // Update status&#10;    await service.update(db, { &#10;      status, &#10;      updated_at: new Date().toISOString() &#10;    });&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Service status updated successfully'&#10;    });&#10;  } catch (error) {&#10;    console.error('Update service status error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error updating service status: ' + error.message&#10;    });&#10;  }&#10;};&#10;&#10;module.exports = {&#10;  getServices,&#10;  getServiceById,&#10;  createServiceBooking,&#10;  getUserServiceBookings,&#10;  getAllServiceBookings,&#10;  updateServiceBookingStatus,&#10;  // Admin functions&#10;  createService,&#10;  updateService,&#10;  deleteService,&#10;  updateServiceStatus,&#10;  upload // Export the multer upload middleware&#10;};&#10;" />
              <option name="updatedContent" value="const { getDB, generateId, generateBookingNumber } = require('../config/database');&#10;const Service = require('../models/Service');&#10;const Category = require('../models/Category');&#10;const { r2Helpers } = require('../config/storage');&#10;const multer = require('multer');&#10;&#10;// Configure multer for memory storage (files will be uploaded to R2)&#10;const storage = multer.memoryStorage();&#10;const upload = multer({&#10;  storage: storage,&#10;  limits: {&#10;    fileSize: 5 * 1024 * 1024, // 5MB limit&#10;  },&#10;  fileFilter: (req, file, cb) =&gt; {&#10;    // Accept only image files&#10;    if (file.mimetype.startsWith('image/')) {&#10;      cb(null, true);&#10;    } else {&#10;      cb(new Error('Only image files are allowed'), false);&#10;    }&#10;  }&#10;});&#10;&#10;// Get all services with filtering&#10;const getServices = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const {&#10;      category,&#10;      serviceType,&#10;      status = 'active',&#10;      featured,&#10;      search,&#10;      page = 1,&#10;      limit = 12,&#10;      sortBy = 'created_at',&#10;      sortOrder = 'desc'&#10;    } = req.query;&#10;&#10;    // Updated query to join with categories table&#10;    let query = `&#10;      SELECT s.*, c.name as category_name, c.slug as category_slug, c.icon as category_icon, c.color as category_color&#10;      FROM services s&#10;      LEFT JOIN categories c ON s.category_id = c.id&#10;    `;&#10;    const conditions = [];&#10;    const params = [];&#10;&#10;    // Only show active services for non-admin users&#10;    if (req.user?.role !== 'admin') {&#10;      conditions.push('s.status = ?');&#10;      params.push('active');&#10;    } else if (status) {&#10;      conditions.push('s.status = ?');&#10;      params.push(status);&#10;    }&#10;&#10;    // Filter by category slug or ID&#10;    if (category) {&#10;      conditions.push('(c.slug = ? OR s.category_id = ?)');&#10;      params.push(category, category);&#10;    }&#10;&#10;    if (serviceType) {&#10;      conditions.push('s.service_type = ?');&#10;      params.push(serviceType);&#10;    }&#10;&#10;    if (featured !== undefined) {&#10;      conditions.push('s.featured = ?');&#10;      params.push(featured === 'true' ? 1 : 0);&#10;    }&#10;&#10;    if (search) {&#10;      conditions.push('(s.title LIKE ? OR s.subtitle LIKE ? OR s.description LIKE ?)');&#10;      const searchTerm = `%${search}%`;&#10;      params.push(searchTerm, searchTerm, searchTerm);&#10;    }&#10;&#10;    if (conditions.length &gt; 0) {&#10;      query += ' WHERE ' + conditions.join(' AND ');&#10;    }&#10;&#10;    // Add sorting&#10;    const validSortColumns = ['created_at', 'title', 'price', 'updated_at'];&#10;    const validSortOrders = ['asc', 'desc'];&#10;&#10;    if (validSortColumns.includes(sortBy) &amp;&amp; validSortOrders.includes(sortOrder)) {&#10;      query += ` ORDER BY s.${sortBy} ${sortOrder.toUpperCase()}`;&#10;    }&#10;&#10;    // Add pagination&#10;    const offset = (parseInt(page) - 1) * parseInt(limit);&#10;    query += ` LIMIT ? OFFSET ?`;&#10;    params.push(parseInt(limit), offset);&#10;&#10;    const result = await db.prepare(query).bind(...params).all();&#10;&#10;    // Get total count for pagination&#10;    let countQuery = `&#10;      SELECT COUNT(*) as total &#10;      FROM services s&#10;      LEFT JOIN categories c ON s.category_id = c.id&#10;    `;&#10;    if (conditions.length &gt; 0) {&#10;      countQuery += ' WHERE ' + conditions.join(' AND ');&#10;    }&#10;&#10;    const countResult = await db.prepare(countQuery).bind(...params.slice(0, -2)).first();&#10;    const total = countResult?.total || 0;&#10;&#10;    // Process results and include category information&#10;    const services = result.results?.map(service =&gt; ({&#10;      ...service,&#10;      images: service.images ? JSON.parse(service.images) : [],&#10;      videos: service.videos ? JSON.parse(service.videos) : [],&#10;      included: service.included ? JSON.parse(service.included) : [],&#10;      excluded: service.excluded ? JSON.parse(service.excluded) : [],&#10;      itinerary: service.itinerary ? JSON.parse(service.itinerary) : [],&#10;      location: service.location ? JSON.parse(service.location) : null,&#10;      featured: Boolean(service.featured),&#10;      category: service.category_id ? {&#10;        id: service.category_id,&#10;        name: service.category_name,&#10;        slug: service.category_slug,&#10;        icon: service.category_icon,&#10;        color: service.category_color&#10;      } : null&#10;    })) || [];&#10;&#10;    res.json({&#10;      success: true,&#10;      data: services,&#10;      pagination: {&#10;        currentPage: parseInt(page),&#10;        totalPages: Math.ceil(total / parseInt(limit)),&#10;        totalItems: total,&#10;        hasNext: parseInt(page) &lt; Math.ceil(total / parseInt(limit)),&#10;        hasPrev: parseInt(page) &gt; 1&#10;      }&#10;    });&#10;  } catch (error) {&#10;    console.error('Error fetching services:', error);&#10;    res.status(500).json({ success: false, message: 'Internal server error' });&#10;  }&#10;};&#10;&#10;// Get single service by ID&#10;const getServiceById = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const { id } = req.params;&#10;&#10;    // Updated query to include category information&#10;    const query = `&#10;      SELECT s.*, c.name as category_name, c.slug as category_slug, c.icon as category_icon, c.color as category_color&#10;      FROM services s&#10;      LEFT JOIN categories c ON s.category_id = c.id&#10;      WHERE s.id = ? AND (s.status = &quot;active&quot; OR ? = &quot;admin&quot;)&#10;    `;&#10;&#10;    const result = await db.prepare(query).bind(id, req.user?.role || '').first();&#10;&#10;    if (!result) {&#10;      return res.status(404).json({ success: false, message: 'Service not found' });&#10;    }&#10;&#10;    const service = {&#10;      ...result,&#10;      images: result.images ? JSON.parse(result.images) : [],&#10;      videos: result.videos ? JSON.parse(result.videos) : [],&#10;      included: result.included ? JSON.parse(result.included) : [],&#10;      excluded: result.excluded ? JSON.parse(result.excluded) : [],&#10;      itinerary: result.itinerary ? JSON.parse(result.itinerary) : [],&#10;      location: result.location ? JSON.parse(result.location) : null,&#10;      featured: Boolean(result.featured),&#10;      category: result.category_id ? {&#10;        id: result.category_id,&#10;        name: result.category_name,&#10;        slug: result.category_slug,&#10;        icon: result.category_icon,&#10;        color: result.category_color&#10;      } : null&#10;    };&#10;&#10;    res.json({ success: true, data: service });&#10;  } catch (error) {&#10;    console.error('Error fetching service:', error);&#10;    res.status(500).json({ success: false, message: 'Internal server error' });&#10;  }&#10;};&#10;&#10;// Create service booking&#10;const createServiceBooking = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const {&#10;      serviceId,&#10;      serviceType,&#10;      name,&#10;      email,&#10;      gender,&#10;      dateOfBirth,&#10;      phone,&#10;      address,&#10;      passengers,&#10;      departureDate,&#10;      from,&#10;      to,&#10;      returnTrip,&#10;      returnDate,&#10;      tripDetails,&#10;      requestDetails&#10;    } = req.body;&#10;&#10;    // Validate required fields&#10;    if (!serviceId || !name || !email || !phone || !passengers) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'Missing required fields'&#10;      });&#10;    }&#10;&#10;    // Check if service exists&#10;    const service = await db.prepare('SELECT * FROM services WHERE id = ? AND status = &quot;active&quot;')&#10;      .bind(serviceId).first();&#10;&#10;    if (!service) {&#10;      return res.status(404).json({ success: false, message: 'Service not found' });&#10;    }&#10;&#10;    // Validate service type specific fields&#10;    if (serviceType === 'tours' &amp;&amp; !departureDate) {&#10;      return res.status(400).json({ success: false, message: 'Departure date is required for tours' });&#10;    }&#10;&#10;    if (serviceType === 'car-rental' &amp;&amp; (!departureDate || !from || !to || !tripDetails)) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'Departure date, from, to, and trip details are required for car rental'&#10;      });&#10;    }&#10;&#10;    if (serviceType === 'other-services' &amp;&amp; !requestDetails) {&#10;      return res.status(400).json({ success: false, message: 'Request details are required for other services' });&#10;    }&#10;&#10;    const bookingId = generateId();&#10;    const bookingNumber = generateBookingNumber();&#10;&#10;    // Prepare booking form data&#10;    const bookingForm = {&#10;      serviceId,&#10;      serviceType,&#10;      name,&#10;      email,&#10;      gender,&#10;      dateOfBirth,&#10;      phone,&#10;      address,&#10;      passengers,&#10;      ...(departureDate &amp;&amp; { departureDate }),&#10;      ...(from &amp;&amp; { from }),&#10;      ...(to &amp;&amp; { to }),&#10;      ...(returnTrip !== undefined &amp;&amp; { returnTrip }),&#10;      ...(returnDate &amp;&amp; { returnDate }),&#10;      ...(tripDetails &amp;&amp; { tripDetails }),&#10;      ...(requestDetails &amp;&amp; { requestDetails })&#10;    };&#10;&#10;    const query = `&#10;      INSERT INTO service_bookings (&#10;        id, booking_number, service_id, customer_id, booking_form, status&#10;      ) VALUES (?, ?, ?, ?, ?, 'pending')&#10;    `;&#10;&#10;    await db.prepare(query).bind(&#10;      bookingId,&#10;      bookingNumber,&#10;      serviceId,&#10;      req.user.id,&#10;      JSON.stringify(bookingForm)&#10;    ).run();&#10;&#10;    res.status(201).json({&#10;      success: true,&#10;      message: 'Service booking created successfully',&#10;      data: { bookingNumber }&#10;    });&#10;  } catch (error) {&#10;    console.error('Error creating service booking:', error);&#10;    res.status(500).json({ success: false, message: 'Internal server error' });&#10;  }&#10;};&#10;&#10;// Get user's service bookings&#10;const getUserServiceBookings = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const query = `&#10;      SELECT sb.*, s.title as service_title, s.subtitle as service_subtitle, s.images as service_images&#10;      FROM service_bookings sb&#10;      JOIN services s ON sb.service_id = s.id&#10;      WHERE sb.customer_id = ?&#10;      ORDER BY sb.created_at DESC&#10;    `;&#10;&#10;    const result = await db.prepare(query).bind(req.user.id).all();&#10;&#10;    const bookings = result.results?.map(booking =&gt; ({&#10;      ...booking,&#10;      booking_form: booking.booking_form ? JSON.parse(booking.booking_form) : {},&#10;      notes: booking.notes ? JSON.parse(booking.notes) : [],&#10;      service: {&#10;        title: booking.service_title,&#10;        subtitle: booking.service_subtitle,&#10;        images: booking.service_images ? JSON.parse(booking.service_images) : []&#10;      }&#10;    })) || [];&#10;&#10;    res.json({ success: true, data: bookings });&#10;  } catch (error) {&#10;    console.error('Error fetching user service bookings:', error);&#10;    res.status(500).json({ success: false, message: 'Internal server error' });&#10;  }&#10;};&#10;&#10;// Admin: Get all service bookings&#10;const getAllServiceBookings = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const {&#10;      status,&#10;      serviceType,&#10;      page = 1,&#10;      limit = 20,&#10;      sortBy = 'created_at',&#10;      sortOrder = 'desc'&#10;    } = req.query;&#10;&#10;    let query = `&#10;      SELECT sb.*, s.title as service_title, s.service_type, u.name as customer_name, u.email as customer_email&#10;      FROM service_bookings sb&#10;      JOIN services s ON sb.service_id = s.id&#10;      JOIN users u ON sb.customer_id = u.id&#10;    `;&#10;&#10;    const conditions = [];&#10;    const params = [];&#10;&#10;    if (status) {&#10;      conditions.push('sb.status = ?');&#10;      params.push(status);&#10;    }&#10;&#10;    if (serviceType) {&#10;      conditions.push('s.service_type = ?');&#10;      params.push(serviceType);&#10;    }&#10;&#10;    if (conditions.length &gt; 0) {&#10;      query += ' WHERE ' + conditions.join(' AND ');&#10;    }&#10;&#10;    // Add sorting&#10;    const validSortColumns = ['created_at', 'updated_at', 'booking_number'];&#10;    const validSortOrders = ['asc', 'desc'];&#10;&#10;    if (validSortColumns.includes(sortBy) &amp;&amp; validSortOrders.includes(sortOrder)) {&#10;      query += ` ORDER BY sb.${sortBy} ${sortOrder.toUpperCase()}`;&#10;    }&#10;&#10;    // Add pagination&#10;    const offset = (parseInt(page) - 1) * parseInt(limit);&#10;    query += ` LIMIT ? OFFSET ?`;&#10;    params.push(parseInt(limit), offset);&#10;&#10;    const result = await db.prepare(query).bind(...params).all();&#10;&#10;    const bookings = result.results?.map(booking =&gt; ({&#10;      ...booking,&#10;      booking_form: booking.booking_form ? JSON.parse(booking.booking_form) : {},&#10;      notes: booking.notes ? JSON.parse(booking.notes) : []&#10;    })) || [];&#10;&#10;    res.json({ success: true, data: bookings });&#10;  } catch (error) {&#10;    console.error('Error fetching service bookings:', error);&#10;    res.status(500).json({ success: false, message: 'Internal server error' });&#10;  }&#10;};&#10;&#10;// Admin: Update service booking status&#10;const updateServiceBookingStatus = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const { id } = req.params;&#10;    const { status, note } = req.body;&#10;&#10;    if (!['pending', 'contacted', 'confirmed', 'completed', 'cancelled'].includes(status)) {&#10;      return res.status(400).json({ success: false, message: 'Invalid status' });&#10;    }&#10;&#10;    // Check if booking exists&#10;    const booking = await db.prepare('SELECT * FROM service_bookings WHERE id = ?').bind(id).first();&#10;    if (!booking) {&#10;      return res.status(404).json({ success: false, message: 'Booking not found' });&#10;    }&#10;&#10;    // Update status and timestamps&#10;    let updateFields = ['status = ?', 'updated_at = CURRENT_TIMESTAMP'];&#10;    let params = [status];&#10;&#10;    if (status === 'contacted') {&#10;      updateFields.push('contacted_at = CURRENT_TIMESTAMP');&#10;    } else if (status === 'confirmed') {&#10;      updateFields.push('confirmed_at = CURRENT_TIMESTAMP');&#10;    }&#10;&#10;    // Add note if provided&#10;    if (note) {&#10;      const existingNotes = booking.notes ? JSON.parse(booking.notes) : [];&#10;      const newNote = {&#10;        content: note,&#10;        author: req.user.name,&#10;        createdAt: new Date().toISOString()&#10;      };&#10;      updateFields.push('notes = ?');&#10;      params.push(JSON.stringify([...existingNotes, newNote]));&#10;    }&#10;&#10;    const query = `UPDATE service_bookings SET ${updateFields.join(', ')} WHERE id = ?`;&#10;    params.push(id);&#10;&#10;    await db.prepare(query).bind(...params).run();&#10;&#10;    res.json({ success: true, message: 'Booking status updated successfully' });&#10;  } catch (error) {&#10;    console.error('Error updating service booking status:', error);&#10;    res.status(500).json({ success: false, message: 'Internal server error' });&#10;  }&#10;};&#10;&#10;// Admin: Create new service&#10;const createService = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const serviceData = req.body;&#10;    &#10;    // Parse JSON fields from FormData if they're strings&#10;    if (serviceData.included &amp;&amp; typeof serviceData.included === 'string') {&#10;      serviceData.included = JSON.parse(serviceData.included);&#10;    }&#10;    if (serviceData.excluded &amp;&amp; typeof serviceData.excluded === 'string') {&#10;      serviceData.excluded = JSON.parse(serviceData.excluded);&#10;    }&#10;    if (serviceData.features &amp;&amp; typeof serviceData.features === 'string') {&#10;      serviceData.features = JSON.parse(serviceData.features);&#10;    }&#10;&#10;    // Create new service instance&#10;    const service = new Service({&#10;      title: serviceData.name,&#10;      subtitle: serviceData.subtitle || '',&#10;      description: serviceData.description,&#10;      price: parseFloat(serviceData.price),&#10;      duration: serviceData.duration,&#10;      category: serviceData.category,&#10;      service_type: serviceData.category, // Map category to service_type&#10;      included: serviceData.features || [],&#10;      excluded: serviceData.excluded || [],&#10;      status: serviceData.status || 'active',&#10;      featured: serviceData.featured || false&#10;    });&#10;&#10;    // Handle image uploads if files are provided&#10;    if (req.files &amp;&amp; req.files.length &gt; 0) {&#10;      try {&#10;        const uploadedImages = await service.updateImages(&#10;          process.env.R2_BUCKET_NAME,&#10;          req.files,&#10;          []&#10;        );&#10;        console.log(`Uploaded ${uploadedImages.length} images for service`);&#10;      } catch (imageError) {&#10;        console.error('Image upload error:', imageError);&#10;        return res.status(400).json({&#10;          success: false,&#10;          message: 'Error uploading images: ' + imageError.message&#10;        });&#10;      }&#10;    }&#10;&#10;    // Save service to database&#10;    const result = await service.save(db);&#10;    &#10;    res.status(201).json({&#10;      success: true,&#10;      message: 'Service created successfully',&#10;      data: service.toJSON ? service.toJSON() : service&#10;    });&#10;  } catch (error) {&#10;    console.error('Create service error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error creating service: ' + error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Admin: Update existing service&#10;const updateService = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const { id } = req.params;&#10;    const updateData = req.body;&#10;&#10;    // Check if service exists&#10;    const existingService = await Service.findById(db, id);&#10;    if (!existingService) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Service not found'&#10;      });&#10;    }&#10;&#10;    // Parse JSON fields if they're strings&#10;    if (updateData.included &amp;&amp; typeof updateData.included === 'string') {&#10;      updateData.included = JSON.parse(updateData.included);&#10;    }&#10;    if (updateData.excluded &amp;&amp; typeof updateData.excluded === 'string') {&#10;      updateData.excluded = JSON.parse(updateData.excluded);&#10;    }&#10;    if (updateData.features &amp;&amp; typeof updateData.features === 'string') {&#10;      updateData.features = JSON.parse(updateData.features);&#10;    }&#10;&#10;    // Prepare update data&#10;    const serviceUpdateData = {&#10;      title: updateData.name || existingService.title,&#10;      subtitle: updateData.subtitle || existingService.subtitle,&#10;      description: updateData.description || existingService.description,&#10;      price: updateData.price ? parseFloat(updateData.price) : existingService.price,&#10;      duration: updateData.duration || existingService.duration,&#10;      category: updateData.category || existingService.category,&#10;      service_type: updateData.category || existingService.service_type,&#10;      included: updateData.features || existingService.included,&#10;      excluded: updateData.excluded || existingService.excluded,&#10;      status: updateData.status || existingService.status,&#10;      featured: updateData.featured !== undefined ? updateData.featured : existingService.featured,&#10;      updated_at: new Date().toISOString()&#10;    };&#10;&#10;    // Handle image uploads if new files are provided&#10;    if (req.files &amp;&amp; req.files.length &gt; 0) {&#10;      try {&#10;        const uploadedImages = await existingService.updateImages(&#10;          process.env.R2_BUCKET_NAME,&#10;          req.files,&#10;          existingService.images || []&#10;        );&#10;        serviceUpdateData.images = JSON.stringify(uploadedImages);&#10;        console.log(`Updated ${uploadedImages.length} images for service`);&#10;      } catch (imageError) {&#10;        console.error('Image update error:', imageError);&#10;        return res.status(400).json({&#10;          success: false,&#10;          message: 'Error updating images: ' + imageError.message&#10;        });&#10;      }&#10;    }&#10;&#10;    // Update service in database&#10;    await existingService.update(db, serviceUpdateData);&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Service updated successfully',&#10;      data: { ...existingService, ...serviceUpdateData }&#10;    });&#10;  } catch (error) {&#10;    console.error('Update service error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error updating service: ' + error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Admin: Delete service&#10;const deleteService = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const { id } = req.params;&#10;&#10;    // Check if service exists&#10;    const service = await Service.findById(db, id);&#10;    if (!service) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Service not found'&#10;      });&#10;    }&#10;&#10;    // Delete service (this will also handle image cleanup)&#10;    await service.delete(db, process.env.R2_BUCKET_NAME);&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Service deleted successfully'&#10;    });&#10;  } catch (error) {&#10;    console.error('Delete service error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error deleting service: ' + error.message&#10;    });&#10;  }&#10;};&#10;&#10;// Admin: Update service status&#10;const updateServiceStatus = async (req, res) =&gt; {&#10;  try {&#10;    const db = getDB(req);&#10;    if (!db) {&#10;      return res.status(500).json({ success: false, message: 'Database not available' });&#10;    }&#10;&#10;    const { id } = req.params;&#10;    const { status } = req.body;&#10;&#10;    if (!['active', 'inactive'].includes(status)) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        message: 'Invalid status. Must be &quot;active&quot; or &quot;inactive&quot;'&#10;      });&#10;    }&#10;&#10;    // Check if service exists&#10;    const service = await Service.findById(db, id);&#10;    if (!service) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Service not found'&#10;      });&#10;    }&#10;&#10;    // Update status&#10;    await service.update(db, { &#10;      status, &#10;      updated_at: new Date().toISOString() &#10;    });&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Service status updated successfully'&#10;    });&#10;  } catch (error) {&#10;    console.error('Update service status error:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Error updating service status: ' + error.message&#10;    });&#10;  }&#10;};&#10;&#10;module.exports = {&#10;  getServices,&#10;  getServiceById,&#10;  createServiceBooking,&#10;  getUserServiceBookings,&#10;  getAllServiceBookings,&#10;  updateServiceBookingStatus,&#10;  // Admin functions&#10;  createService,&#10;  updateService,&#10;  deleteService,&#10;  updateServiceStatus,&#10;  upload // Export the multer upload middleware&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/utils/api.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/utils/api.ts" />
              <option name="originalContent" value="import axios, { AxiosResponse } from 'axios';&#10;import {&#10;    User,&#10;    Tour,&#10;    Booking,&#10;    Review,&#10;    Content,&#10;    TourFilters,&#10;    ApiResponse,&#10;    PaginationResponse, Service&#10;} from '../types';&#10;// Create admin axios instance&#10;const adminAPI = axios.create({&#10;  baseURL: process.env.REACT_APP_API_URL || 'http://localhost:5000/api',&#10;  headers: {&#10;    'Content-Type': 'application/json',&#10;  },&#10;});&#10;&#10;// Request interceptor for admin API to add auth token&#10;adminAPI.interceptors.request.use(&#10;  (config) =&gt; {&#10;    const token = localStorage.getItem('adminToken');&#10;    if (token) {&#10;      config.headers.Authorization = `Bearer ${token}`;&#10;    }&#10;    return config;&#10;  },&#10;  (error) =&gt; {&#10;    return Promise.reject(error);&#10;  }&#10;);&#10;&#10;// Response interceptor for admin API to handle errors&#10;adminAPI.interceptors.response.use(&#10;  (response) =&gt; response,&#10;  (error) =&gt; {&#10;    if (error.response?.status === 401) {&#10;      localStorage.removeItem('adminToken');&#10;      window.location.href = '/admin/login';&#10;    }&#10;    return Promise.reject(error);&#10;  }&#10;);&#10;&#10;// Auth API (Admin only)&#10;export const authAPI = {&#10;  adminLogin: (email: string, password: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;{ user: User; token: string }&gt;&gt;&gt; =&gt;&#10;    adminAPI.post('/auth/admin/login', { email, password }),&#10;};&#10;&#10;// Tours API (Public)&#10;export const toursAPI = {&#10;  getTours: (filters?: TourFilters): Promise&lt;AxiosResponse&lt;PaginationResponse&lt;Tour&gt;&gt;&gt; =&gt;&#10;    api.get('/tours', { params: filters }),&#10;&#10;  getFeaturedTours: (): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Tour[]&gt;&gt;&gt; =&gt;&#10;    api.get('/tours/featured'),&#10;&#10;  getTourBySlug: (slug: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Tour&gt;&gt;&gt; =&gt;&#10;    api.get(`/tours/${slug}`),&#10;&#10;  checkAvailability: (tourId: string, date: string, participants: number): Promise&lt;AxiosResponse&lt;ApiResponse&lt;any&gt;&gt;&gt; =&gt;&#10;    api.get(`/tours/${tourId}/availability`, { params: { date, participants } }),&#10;&#10;  // Admin only&#10;  createTour: (tourData: FormData): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Tour&gt;&gt;&gt; =&gt;&#10;    adminAPI.post('/tours', tourData, {&#10;      headers: { 'Content-Type': 'multipart/form-data' }&#10;    }),&#10;&#10;  updateTour: (id: string, tourData: Partial&lt;Tour&gt;): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Tour&gt;&gt;&gt; =&gt;&#10;    adminAPI.put(`/tours/${id}`, tourData),&#10;&#10;  deleteTour: (id: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;void&gt;&gt;&gt; =&gt;&#10;    adminAPI.delete(`/tours/${id}`),&#10;};&#10;&#10;// Services API (Public)&#10;export const servicesAPI = {&#10;  getServices: (): Promise&lt;AxiosResponse&lt;ApiResponse&lt;any[]&gt;&gt;&gt; =&gt;&#10;    api.get('/services'),&#10;&#10;  getServiceById: (id: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Service&gt;&gt;&gt; =&gt;&#10;    api.get(`/services/${id}`),&#10;};&#10;&#10;// Bookings API&#10;export const bookingsAPI = {&#10;  // Public - Direct booking without authentication&#10;  createDirectBooking: (bookingData: {&#10;    type: 'tour' | 'service';&#10;    itemId: string;&#10;    customerInfo: {&#10;      name: string;&#10;      email: string;&#10;      phone: string;&#10;    };&#10;    bookingDetails: {&#10;      startDate: string;&#10;      totalTravelers: number;&#10;      specialRequests?: string;&#10;    };&#10;    pricing: {&#10;      totalAmount: number;&#10;      currency: string;&#10;    };&#10;  }): Promise&lt;AxiosResponse&lt;ApiResponse&lt;{ bookingNumber: string }&gt;&gt;&gt; =&gt;&#10;    api.post('/bookings', bookingData),&#10;&#10;  // Admin only&#10;  getAllBookings: (): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Booking[]&gt;&gt;&gt; =&gt;&#10;    adminAPI.get('/bookings'),&#10;&#10;  updateBookingStatus: (id: string, status: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;void&gt;&gt;&gt; =&gt;&#10;    adminAPI.put(`/bookings/${id}/status`, { status }),&#10;};&#10;&#10;// Content API (Public)&#10;export const contentAPI = {&#10;  getBlogs: (): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Content[]&gt;&gt;&gt; =&gt;&#10;    api.get('/content/blogs'),&#10;&#10;  getBlogBySlug: (slug: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Content&gt;&gt;&gt; =&gt;&#10;    api.get(`/content/blogs/${slug}`),&#10;&#10;  // Admin only&#10;// Reviews API (Public)&#10;export const reviewsAPI = {&#10;  getReviews: (tourId?: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Review[]&gt;&gt;&gt; =&gt;&#10;    api.get('/reviews', { params: { tourId } }),&#10;&#10;  createReview: (reviewData: {&#10;    tourId: string;&#10;    customerName: string;&#10;    customerEmail: string;&#10;    rating: number;&#10;    comment: string;&#10;  }): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Review&gt;&gt;&gt; =&gt;&#10;    api.post('/reviews', reviewData),&#10;};&#10;&#10;  createBlog: (blogData: any): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Content&gt;&gt;&gt; =&gt;&#10;    adminAPI.post('/content/blogs', blogData),&#10;&#10;  updateBlog: (id: string, blogData: any): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Content&gt;&gt;&gt; =&gt;&#10;    adminAPI.put(`/content/blogs/${id}`, blogData),&#10;&#10;  deleteBlog: (id: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;void&gt;&gt;&gt; =&gt;&#10;    adminAPI.delete(`/content/blogs/${id}`),&#10;};&#10;&#10;// Admin API&#10;export const adminAPI_functions = {&#10;  getDashboardStats: (): Promise&lt;AxiosResponse&lt;ApiResponse&lt;any&gt;&gt;&gt; =&gt;&#10;    adminAPI.get('/admin/stats'),&#10;&#10;  getProfile: (): Promise&lt;AxiosResponse&lt;ApiResponse&lt;User&gt;&gt;&gt; =&gt;&#10;    adminAPI.get('/admin/profile'),&#10;};&#10;&#10;export default api;&#10;" />
              <option name="updatedContent" value="import axios, { AxiosResponse } from 'axios';&#10;import {&#10;    User,&#10;    Tour,&#10;    Booking,&#10;    Review,&#10;    Content,&#10;    TourFilters,&#10;    ApiResponse,&#10;    PaginationResponse, Service&#10;} from '../types';&#10;// Create admin axios instance&#10;const adminAPI = axios.create({&#10;  baseURL: process.env.REACT_APP_API_URL || 'http://localhost:5000/api',&#10;  headers: {&#10;    'Content-Type': 'application/json',&#10;  },&#10;});&#10;&#10;// Request interceptor for admin API to add auth token&#10;adminAPI.interceptors.request.use(&#10;  (config) =&gt; {&#10;    const token = localStorage.getItem('adminToken');&#10;    if (token) {&#10;      config.headers.Authorization = `Bearer ${token}`;&#10;    }&#10;    return config;&#10;  },&#10;  (error) =&gt; {&#10;    return Promise.reject(error);&#10;  }&#10;);&#10;&#10;// Response interceptor for admin API to handle errors&#10;adminAPI.interceptors.response.use(&#10;  (response) =&gt; response,&#10;  (error) =&gt; {&#10;    if (error.response?.status === 401) {&#10;      localStorage.removeItem('adminToken');&#10;      window.location.href = '/admin/login';&#10;    }&#10;    return Promise.reject(error);&#10;  }&#10;);&#10;&#10;// Auth API (Admin only)&#10;export const authAPI = {&#10;  adminLogin: (email: string, password: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;{ user: User; token: string }&gt;&gt;&gt; =&gt;&#10;    adminAPI.post('/auth/admin/login', { email, password }),&#10;};&#10;&#10;// Tours API (Public)&#10;export const toursAPI = {&#10;  getTours: (filters?: TourFilters): Promise&lt;AxiosResponse&lt;PaginationResponse&lt;Tour&gt;&gt;&gt; =&gt;&#10;    api.get('/tours', { params: filters }),&#10;&#10;  getFeaturedTours: (): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Tour[]&gt;&gt;&gt; =&gt;&#10;    api.get('/tours/featured'),&#10;&#10;  getTourBySlug: (slug: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Tour&gt;&gt;&gt; =&gt;&#10;    api.get(`/tours/${slug}`),&#10;&#10;  checkAvailability: (tourId: string, date: string, participants: number): Promise&lt;AxiosResponse&lt;ApiResponse&lt;any&gt;&gt;&gt; =&gt;&#10;    api.get(`/tours/${tourId}/availability`, { params: { date, participants } }),&#10;&#10;  // Admin only&#10;  createTour: (tourData: FormData): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Tour&gt;&gt;&gt; =&gt;&#10;    adminAPI.post('/tours', tourData, {&#10;      headers: { 'Content-Type': 'multipart/form-data' }&#10;    }),&#10;&#10;  updateTour: (id: string, tourData: Partial&lt;Tour&gt;): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Tour&gt;&gt;&gt; =&gt;&#10;    adminAPI.put(`/tours/${id}`, tourData),&#10;&#10;  deleteTour: (id: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;void&gt;&gt;&gt; =&gt;&#10;    adminAPI.delete(`/tours/${id}`),&#10;};&#10;&#10;// Services API (Public)&#10;export const servicesAPI = {&#10;  getServices: (): Promise&lt;AxiosResponse&lt;ApiResponse&lt;any[]&gt;&gt;&gt; =&gt;&#10;    api.get('/services'),&#10;&#10;  getServiceById: (id: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Service&gt;&gt;&gt; =&gt;&#10;    api.get(`/services/${id}`),&#10;};&#10;&#10;// Bookings API&#10;export const bookingsAPI = {&#10;  // Public - Direct booking without authentication&#10;  createDirectBooking: (bookingData: {&#10;    type: 'tour' | 'service';&#10;    itemId: string;&#10;    customerInfo: {&#10;      name: string;&#10;      email: string;&#10;      phone: string;&#10;    };&#10;    bookingDetails: {&#10;      startDate: string;&#10;      totalTravelers: number;&#10;      specialRequests?: string;&#10;    };&#10;    pricing: {&#10;      totalAmount: number;&#10;      currency: string;&#10;    };&#10;  }): Promise&lt;AxiosResponse&lt;ApiResponse&lt;{ bookingNumber: string }&gt;&gt;&gt; =&gt;&#10;    api.post('/bookings', bookingData),&#10;&#10;  // Admin only&#10;  getAllBookings: (): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Booking[]&gt;&gt;&gt; =&gt;&#10;    adminAPI.get('/bookings'),&#10;&#10;  updateBookingStatus: (id: string, status: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;void&gt;&gt;&gt; =&gt;&#10;    adminAPI.put(`/bookings/${id}/status`, { status }),&#10;};&#10;&#10;// Content API (Public)&#10;export const contentAPI = {&#10;  getBlogs: (): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Content[]&gt;&gt;&gt; =&gt;&#10;    api.get('/content/blogs'),&#10;&#10;  getBlogBySlug: (slug: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Content&gt;&gt;&gt; =&gt;&#10;    api.get(`/content/blogs/${slug}`),&#10;&#10;  // Admin only&#10;// Reviews API (Public)&#10;export const reviewsAPI = {&#10;  getReviews: (tourId?: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Review[]&gt;&gt;&gt; =&gt;&#10;    api.get('/reviews', { params: { tourId } }),&#10;&#10;  createReview: (reviewData: {&#10;    tourId: string;&#10;    customerName: string;&#10;    customerEmail: string;&#10;    rating: number;&#10;    comment: string;&#10;  }): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Review&gt;&gt;&gt; =&gt;&#10;    api.post('/reviews', reviewData),&#10;};&#10;&#10;  createBlog: (blogData: any): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Content&gt;&gt;&gt; =&gt;&#10;    adminAPI.post('/content/blogs', blogData),&#10;&#10;  updateBlog: (id: string, blogData: any): Promise&lt;AxiosResponse&lt;ApiResponse&lt;Content&gt;&gt;&gt; =&gt;&#10;    adminAPI.put(`/content/blogs/${id}`, blogData),&#10;&#10;  deleteBlog: (id: string): Promise&lt;AxiosResponse&lt;ApiResponse&lt;void&gt;&gt;&gt; =&gt;&#10;    adminAPI.delete(`/content/blogs/${id}`),&#10;};&#10;&#10;// Admin API&#10;export const adminAPI_functions = {&#10;  getDashboardStats: (): Promise&lt;AxiosResponse&lt;ApiResponse&lt;any&gt;&gt;&gt; =&gt;&#10;    adminAPI.get('/admin/stats'),&#10;&#10;  getProfile: (): Promise&lt;AxiosResponse&lt;ApiResponse&lt;User&gt;&gt;&gt; =&gt;&#10;    adminAPI.get('/admin/profile'),&#10;};&#10;&#10;export default api;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/migrate-db.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/migrate-db.sql" />
              <option name="originalContent" value="-- Migration script to override D1 database with new schema&#10;-- WARNING: This will delete all existing data!&#10;&#10;-- Drop all existing tables&#10;DROP TABLE IF EXISTS booking_notes;&#10;DROP TABLE IF EXISTS bookings;&#10;DROP TABLE IF EXISTS reviews;&#10;DROP TABLE IF EXISTS blogs;&#10;DROP TABLE IF EXISTS content;&#10;DROP TABLE IF EXISTS services;&#10;DROP TABLE IF EXISTS tours;&#10;DROP TABLE IF EXISTS users;&#10;&#10;-- Drop all existing indexes&#10;DROP INDEX IF EXISTS idx_users_email;&#10;DROP INDEX IF EXISTS idx_tours_slug;&#10;DROP INDEX IF EXISTS idx_tours_status;&#10;DROP INDEX IF EXISTS idx_services_category;&#10;DROP INDEX IF EXISTS idx_services_status;&#10;DROP INDEX IF EXISTS idx_bookings_status;&#10;DROP INDEX IF EXISTS idx_bookings_customer_email;&#10;DROP INDEX IF EXISTS idx_bookings_booking_number;&#10;DROP INDEX IF EXISTS idx_reviews_status;&#10;&#10;-- Recreate all tables with new schema&#10;-- Users table (Admin only)&#10;CREATE TABLE users (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    name TEXT NOT NULL,&#10;    email TEXT UNIQUE NOT NULL,&#10;    password TEXT NOT NULL,&#10;    phone TEXT,&#10;    role TEXT DEFAULT 'admin' CHECK(role IN ('admin')),&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL&#10;);&#10;&#10;-- Tours table&#10;CREATE TABLE tours (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    title TEXT NOT NULL,&#10;    slug TEXT UNIQUE NOT NULL,&#10;    description TEXT,&#10;    price REAL NOT NULL,&#10;    duration TEXT,&#10;    max_participants INTEGER,&#10;    included TEXT,&#10;    excluded TEXT,&#10;    itinerary TEXT,&#10;    images TEXT,&#10;    status TEXT DEFAULT 'active' CHECK(status IN ('active', 'inactive', 'draft')),&#10;    featured BOOLEAN DEFAULT FALSE,&#10;    category TEXT,&#10;    location TEXT,&#10;    difficulty TEXT CHECK(difficulty IN ('easy', 'moderate', 'hard')),&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL&#10;);&#10;&#10;-- Services table&#10;CREATE TABLE services (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    title TEXT NOT NULL,&#10;    subtitle TEXT,&#10;    description TEXT,&#10;    price REAL NOT NULL,&#10;    duration TEXT,&#10;    images TEXT,&#10;    included TEXT,&#10;    excluded TEXT,&#10;    category TEXT NOT NULL,&#10;    service_type TEXT NOT NULL CHECK(service_type IN ('tours', 'car-rental', 'other-services')),&#10;    status TEXT DEFAULT 'active' CHECK(status IN ('active', 'inactive')),&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL&#10;);&#10;&#10;-- Direct Bookings table (no user account required)&#10;CREATE TABLE bookings (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    booking_number TEXT UNIQUE NOT NULL,&#10;    type TEXT NOT NULL CHECK(type IN ('tour', 'service')),&#10;    item_id INTEGER NOT NULL,&#10;    customer_name TEXT NOT NULL,&#10;    customer_email TEXT NOT NULL,&#10;    customer_phone TEXT NOT NULL,&#10;    start_date TEXT NOT NULL,&#10;    total_travelers INTEGER NOT NULL,&#10;    special_requests TEXT,&#10;    total_amount REAL NOT NULL,&#10;    currency TEXT DEFAULT 'USD',&#10;    status TEXT DEFAULT 'pending' CHECK(status IN ('pending', 'confirmed', 'contacted', 'completed', 'cancelled')),&#10;    contacted_at TEXT,&#10;    confirmed_at TEXT,&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL&#10;);&#10;&#10;-- Booking notes table (for admin use)&#10;CREATE TABLE booking_notes (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    booking_id INTEGER NOT NULL,&#10;    content TEXT NOT NULL,&#10;    created_by INTEGER NOT NULL,&#10;    created_at TEXT NOT NULL,&#10;    FOREIGN KEY (booking_id) REFERENCES bookings(id),&#10;    FOREIGN KEY (created_by) REFERENCES users(id)&#10;);&#10;&#10;-- Reviews table (now accepts reviews from non-registered customers)&#10;CREATE TABLE reviews (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    service_id INTEGER,&#10;    tour_id INTEGER,&#10;    customer_name TEXT NOT NULL,&#10;    customer_email TEXT NOT NULL,&#10;    rating INTEGER NOT NULL CHECK(rating &gt;= 1 AND rating &lt;= 5),&#10;    title TEXT,&#10;    comment TEXT,&#10;    status TEXT DEFAULT 'pending' CHECK(status IN ('pending', 'approved', 'rejected')),&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL,&#10;    FOREIGN KEY (service_id) REFERENCES services(id),&#10;    FOREIGN KEY (tour_id) REFERENCES tours(id)&#10;);&#10;&#10;-- Blogs table&#10;CREATE TABLE blogs (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    type TEXT DEFAULT 'blog',&#10;    title TEXT NOT NULL,&#10;    slug TEXT UNIQUE NOT NULL,&#10;    content TEXT NOT NULL,&#10;    excerpt TEXT,&#10;    featured_image TEXT,&#10;    gallery TEXT,&#10;    author INTEGER NOT NULL,&#10;    status TEXT DEFAULT 'draft' CHECK(status IN ('draft', 'published', 'archived')),&#10;    featured BOOLEAN DEFAULT FALSE,&#10;    categories TEXT,&#10;    tags TEXT,&#10;    language TEXT DEFAULT 'en',&#10;    seo_meta_title TEXT,&#10;    seo_meta_description TEXT,&#10;    seo_keywords TEXT,&#10;    views INTEGER DEFAULT 0,&#10;    reading_time INTEGER,&#10;    published_at TEXT,&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL,&#10;    FOREIGN KEY (author) REFERENCES users(id)&#10;);&#10;&#10;-- Content management table&#10;CREATE TABLE content (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    key TEXT UNIQUE NOT NULL,&#10;    title TEXT,&#10;    content TEXT,&#10;    type TEXT CHECK(type IN ('page', 'section', 'setting')),&#10;    language TEXT DEFAULT 'en',&#10;    status TEXT DEFAULT 'active' CHECK(status IN ('active', 'inactive')),&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL&#10;);&#10;&#10;-- Create indexes for better performance&#10;CREATE INDEX idx_users_email ON users(email);&#10;CREATE INDEX idx_tours_slug ON tours(slug);&#10;CREATE INDEX idx_tours_status ON tours(status);&#10;CREATE INDEX idx_services_category ON services(category);&#10;CREATE INDEX idx_services_status ON services(status);&#10;CREATE INDEX idx_bookings_status ON bookings(status);&#10;CREATE INDEX idx_bookings_customer_email ON bookings(customer_email);&#10;CREATE INDEX idx_bookings_booking_number ON bookings(booking_number);&#10;CREATE INDEX idx_reviews_status ON reviews(status);&#10;&#10;-- Insert a default admin user (change password before production!)&#10;INSERT INTO users (name, email, password, role, created_at, updated_at)&#10;VALUES (&#10;    'Admin User',&#10;    'admin@example.com',&#10;    '$2a$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', -- password: &quot;password&quot;&#10;    'admin',&#10;    datetime('now'),&#10;    datetime('now')&#10;);&#10;" />
              <option name="updatedContent" value="-- Migration script to override D1 database with new schema&#10;-- WARNING: This will delete all existing data!&#10;&#10;-- Drop all existing tables&#10;DROP TABLE IF EXISTS booking_notes;&#10;DROP TABLE IF EXISTS bookings;&#10;DROP TABLE IF EXISTS reviews;&#10;DROP TABLE IF EXISTS blogs;&#10;DROP TABLE IF EXISTS content;&#10;DROP TABLE IF EXISTS services;&#10;DROP TABLE IF EXISTS tours;&#10;DROP TABLE IF EXISTS users;&#10;&#10;-- Drop all existing indexes&#10;DROP INDEX IF EXISTS idx_users_email;&#10;DROP INDEX IF EXISTS idx_tours_slug;&#10;DROP INDEX IF EXISTS idx_tours_status;&#10;DROP INDEX IF EXISTS idx_services_category;&#10;DROP INDEX IF EXISTS idx_services_status;&#10;DROP INDEX IF EXISTS idx_bookings_status;&#10;DROP INDEX IF EXISTS idx_bookings_customer_email;&#10;DROP INDEX IF EXISTS idx_reviews_status;&#10;&#10;-- Recreate all tables with new schema&#10;-- Users table (Admin only)&#10;CREATE TABLE users (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    name TEXT NOT NULL,&#10;    email TEXT UNIQUE NOT NULL,&#10;    password TEXT NOT NULL,&#10;    phone TEXT,&#10;    role TEXT DEFAULT 'admin' CHECK(role IN ('admin')),&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL&#10;);&#10;&#10;-- Tours table&#10;CREATE TABLE tours (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    title TEXT NOT NULL,&#10;    slug TEXT UNIQUE NOT NULL,&#10;    description TEXT,&#10;    price REAL NOT NULL,&#10;    duration TEXT,&#10;    max_participants INTEGER,&#10;    included TEXT,&#10;    excluded TEXT,&#10;    itinerary TEXT,&#10;    images TEXT,&#10;    status TEXT DEFAULT 'active' CHECK(status IN ('active', 'inactive', 'draft')),&#10;    featured BOOLEAN DEFAULT FALSE,&#10;    category TEXT,&#10;    location TEXT,&#10;    difficulty TEXT CHECK(difficulty IN ('easy', 'moderate', 'hard')),&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL&#10;);&#10;&#10;-- Services table&#10;CREATE TABLE services (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    title TEXT NOT NULL,&#10;    subtitle TEXT,&#10;    description TEXT,&#10;    price REAL NOT NULL,&#10;    duration TEXT,&#10;    images TEXT,&#10;    included TEXT,&#10;    excluded TEXT,&#10;    category TEXT NOT NULL,&#10;    service_type TEXT NOT NULL CHECK(service_type IN ('tours', 'car-rental', 'other-services')),&#10;    status TEXT DEFAULT 'active' CHECK(status IN ('active', 'inactive')),&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL&#10;);&#10;&#10;-- Direct Bookings table (no user account required)&#10;CREATE TABLE bookings (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    booking_number TEXT UNIQUE NOT NULL,&#10;    type TEXT NOT NULL CHECK(type IN ('tour', 'service')),&#10;    item_id INTEGER NOT NULL,&#10;    customer_name TEXT NOT NULL,&#10;    customer_email TEXT NOT NULL,&#10;    customer_phone TEXT NOT NULL,&#10;    start_date TEXT NOT NULL,&#10;    total_travelers INTEGER NOT NULL,&#10;    special_requests TEXT,&#10;    total_amount REAL NOT NULL,&#10;    currency TEXT DEFAULT 'USD',&#10;    status TEXT DEFAULT 'pending' CHECK(status IN ('pending', 'confirmed', 'contacted', 'completed', 'cancelled')),&#10;    contacted_at TEXT,&#10;    confirmed_at TEXT,&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL&#10;);&#10;&#10;-- Booking notes table (for admin use)&#10;CREATE TABLE booking_notes (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    booking_id INTEGER NOT NULL,&#10;    content TEXT NOT NULL,&#10;    created_by INTEGER NOT NULL,&#10;    created_at TEXT NOT NULL,&#10;    FOREIGN KEY (booking_id) REFERENCES bookings(id),&#10;    FOREIGN KEY (created_by) REFERENCES users(id)&#10;);&#10;&#10;-- Reviews table (now accepts reviews from non-registered customers)&#10;CREATE TABLE reviews (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    service_id INTEGER,&#10;    tour_id INTEGER,&#10;    customer_name TEXT NOT NULL,&#10;    customer_email TEXT NOT NULL,&#10;    rating INTEGER NOT NULL CHECK(rating &gt;= 1 AND rating &lt;= 5),&#10;    title TEXT,&#10;    comment TEXT,&#10;    status TEXT DEFAULT 'pending' CHECK(status IN ('pending', 'approved', 'rejected')),&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL,&#10;    FOREIGN KEY (service_id) REFERENCES services(id),&#10;    FOREIGN KEY (tour_id) REFERENCES tours(id)&#10;);&#10;&#10;-- Blogs table&#10;CREATE TABLE blogs (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    type TEXT DEFAULT 'blog',&#10;    title TEXT NOT NULL,&#10;    slug TEXT UNIQUE NOT NULL,&#10;    content TEXT NOT NULL,&#10;    excerpt TEXT,&#10;    featured_image TEXT,&#10;    gallery TEXT,&#10;    author INTEGER NOT NULL,&#10;    status TEXT DEFAULT 'draft' CHECK(status IN ('draft', 'published', 'archived')),&#10;    featured BOOLEAN DEFAULT FALSE,&#10;    categories TEXT,&#10;    tags TEXT,&#10;    language TEXT DEFAULT 'en',&#10;    seo_meta_title TEXT,&#10;    seo_meta_description TEXT,&#10;    seo_keywords TEXT,&#10;    views INTEGER DEFAULT 0,&#10;    reading_time INTEGER,&#10;    published_at TEXT,&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL,&#10;    FOREIGN KEY (author) REFERENCES users(id)&#10;);&#10;&#10;-- Content management table&#10;CREATE TABLE content (&#10;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;    key TEXT UNIQUE NOT NULL,&#10;    title TEXT,&#10;    content TEXT,&#10;    type TEXT CHECK(type IN ('page', 'section', 'setting')),&#10;    language TEXT DEFAULT 'en',&#10;    status TEXT DEFAULT 'active' CHECK(status IN ('active', 'inactive')),&#10;    created_at TEXT NOT NULL,&#10;    updated_at TEXT NOT NULL&#10;);&#10;&#10;-- Create indexes for better performance&#10;CREATE INDEX idx_users_email ON users(email);&#10;CREATE INDEX idx_tours_slug ON tours(slug);&#10;CREATE INDEX idx_tours_status ON tours(status);&#10;CREATE INDEX idx_services_category ON services(category);&#10;CREATE INDEX idx_services_status ON services(status);&#10;CREATE INDEX idx_bookings_status ON bookings(status);&#10;CREATE INDEX idx_bookings_customer_email ON bookings(customer_email);&#10;CREATE INDEX idx_reviews_status ON reviews(status);&#10;CREATE INDEX idx_bookings_booking_number ON bookings(booking_number);&#10;&#10;-- Insert a default admin user (change password before production!)&#10;INSERT INTO users (name, email, password, role, created_at, updated_at)&#10;VALUES (&#10;    'Admin User',&#10;    'admin@example.com',&#10;    '$2a$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi', -- password: &quot;password&quot;&#10;    'admin',&#10;    datetime('now'),&#10;    datetime('now')&#10;);" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>